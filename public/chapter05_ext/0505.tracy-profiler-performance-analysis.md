# Tracy Profiler - C++æ€§èƒ½åˆ†æåˆ©å™¨

> å®æ—¶C++æ€§èƒ½åˆ†æå™¨ï¼Œæä¾›çº³ç§’çº§ç²¾åº¦çš„æ€§èƒ½åˆ†æï¼Œæ”¯æŒCPU/GPUåˆ†æã€å†…å­˜è¿½è¸ªã€é”åˆ†æç­‰åŠŸèƒ½

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [æ ¸å¿ƒç‰¹æ€§](#2-æ ¸å¿ƒç‰¹æ€§)
3. [æ€§èƒ½æŒ‡æ ‡](#3-æ€§èƒ½æŒ‡æ ‡)
4. [å¿«é€Ÿå¼€å§‹](#4-å¿«é€Ÿå¼€å§‹)
5. [é›†æˆæŒ‡å—](#5-é›†æˆæŒ‡å—)
6. [åˆ†æåŠŸèƒ½è¯¦è§£](#6-åˆ†æåŠŸèƒ½è¯¦è§£)
7. [é«˜çº§é…ç½®](#7-é«˜çº§é…ç½®)
8. [æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
9. [æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹](#9-æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹)

## 1. é¡¹ç›®æ¦‚è¿°

Tracy Profiler æ˜¯ä¸€æ¬¾åŠŸèƒ½å¼ºå¤§çš„å®æ—¶C++æ€§èƒ½åˆ†æå™¨ï¼Œä¸“ä¸ºæ¸¸æˆå¼€å‘è€…å’Œé«˜æ€§èƒ½åº”ç”¨å¼€å‘è€…è®¾è®¡ã€‚é€šè¿‡çº³ç§’çº§ç²¾åº¦çš„æ—¶é—´æµ‹é‡å’Œå®æ—¶åˆ†æèƒ½åŠ›ï¼ŒTracyå¸®åŠ©å¼€å‘è€…å¿«é€Ÿå®šä½æ€§èƒ½ç“¶é¢ˆï¼Œä¼˜åŒ–åº”ç”¨ç¨‹åºæ€§èƒ½ã€‚

### ğŸ¯ è®¾è®¡ç†å¿µ

- **å®æ—¶åˆ†æ** - åº”ç”¨è¿è¡Œæ—¶å³å¯æŸ¥çœ‹æ€§èƒ½æ•°æ®
- **é«˜ç²¾åº¦æµ‹é‡** - çº³ç§’çº§æ—¶é—´ç²¾åº¦ï¼Œå‡†ç¡®æµ‹é‡å¾®å°æ€§èƒ½å·®å¼‚
- **é›¶å¼€é”€** - æœ€å°åŒ–å¯¹åº”ç”¨ç¨‹åºæ€§èƒ½çš„å½±å“
- **å¯è§†åŒ–ç•Œé¢** - ç›´è§‚çš„å›¾è¡¨å’Œç»Ÿè®¡æ•°æ®å±•ç¤º

## 2. æ ¸å¿ƒç‰¹æ€§

### âœ¨ ä¸»è¦åŠŸèƒ½

- **â±ï¸ çº³ç§’çº§ç²¾åº¦** - è¶…é«˜ç²¾åº¦æ—¶é—´æµ‹é‡ï¼Œå‡†ç¡®æ•è·æ€§èƒ½ç»†èŠ‚
- **ğŸ“Š å®æ—¶åˆ†æ** - åº”ç”¨è¿è¡Œæ—¶å®æ—¶æŸ¥çœ‹æ€§èƒ½æ•°æ®å’Œåˆ†æç»“æœ
- **ğŸ–¥ï¸ CPU & GPU åˆ†æ** - åŒæ—¶æ”¯æŒCPUå’ŒGPUæ€§èƒ½åˆ†æ
- **ğŸ’¾ å†…å­˜è¿½è¸ª** - å®æ—¶ç›‘æ§å†…å­˜åˆ†é…ã€é‡Šæ”¾å’Œæ³„æ¼æ£€æµ‹
- **ğŸ”’ é”åˆ†æ** - åˆ†æé”ç«äº‰ã€æ­»é”å’ŒåŒæ­¥é—®é¢˜
- **ğŸ“ˆ å¯è§†åŒ–ç•Œé¢** - ç›´è§‚çš„æ—¶é—´çº¿å’Œç»Ÿè®¡å›¾è¡¨
- **ğŸ® å¸§æ—¶é—´åˆ†æ** - ä¸“ä¸ºæ¸¸æˆåº”ç”¨ä¼˜åŒ–çš„å¸§ç‡åˆ†æ
- **âš™ï¸ é›¶é…ç½®é›†æˆ** - ç®€å•æ˜“ç”¨çš„APIï¼Œæ— éœ€å¤æ‚é…ç½®

## 3. æ€§èƒ½æŒ‡æ ‡

### â±ï¸ æ—¶é—´æµ‹é‡

#### ç²¾åº¦æŒ‡æ ‡
- **åŸºç¡€ç²¾åº¦**: çº³ç§’çº§ (1ns)
- **æœ€å°é—´éš”**: 10ns
- **æœ€å¤§å»¶è¿Ÿ**: <100Î¼s
- **æ—¶é—´åŒæ­¥**: å¤šçº¿ç¨‹æ—¶é—´åŒæ­¥ç²¾åº¦ <1Î¼s

#### æµ‹é‡èŒƒå›´
```cpp
// Tracyæ”¯æŒçš„æ—¶é—´æµ‹é‡èŒƒå›´
TimeRange:
  æœ€å°: 10 nanoseconds
  æœ€å¤§: 2^63 nanoseconds (~292å¹´)
  ç²¾åº¦: å¹³å°ä¾èµ–ï¼Œé€šå¸¸ <50ns
```

### ğŸ–¥ï¸ CPU åˆ†æ

#### CPUæ€§èƒ½æŒ‡æ ‡
- **CPUä½¿ç”¨ç‡**: å®æ—¶CPUä½¿ç”¨ç™¾åˆ†æ¯”
- **ä¸Šä¸‹æ–‡åˆ‡æ¢**: çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢æ¬¡æ•°å’Œæ—¶é—´
- **ç¼“å­˜å‘½ä¸­ç‡**: L1/L2/L3ç¼“å­˜å‘½ä¸­ç‡
- **åˆ†æ”¯é¢„æµ‹**: åˆ†æ”¯é¢„æµ‹æˆåŠŸç‡å’Œå¤±è´¥æˆæœ¬
- **æŒ‡ä»¤çº§æ€§èƒ½**: IPC (Instructions Per Cycle)
- **çƒ­ç‚¹å‡½æ•°**: æ‰§è¡Œæ—¶é—´æœ€é•¿çš„å‡½æ•°æ’å

```cpp
// CPUåˆ†æç¤ºä¾‹
CPU_Metrics:
  total_time: 1.234s
  cpu_usage: 87.5%
  context_switches: 1,234
  cache_misses: 456
  ipc: 2.1
  top_functions:
    - render_frame(): 450ms
    - update_physics(): 280ms
    - process_input(): 120ms
```

### ğŸ® GPU åˆ†æ

#### GPUæ€§èƒ½æŒ‡æ ‡
- **GPUä½¿ç”¨ç‡**: GPUè®¡ç®—å•å…ƒä½¿ç”¨ç™¾åˆ†æ¯”
- **æ˜¾å­˜ä½¿ç”¨**: VRAMä½¿ç”¨é‡å’Œåˆ†é…æ¨¡å¼
- **ç»˜åˆ¶è°ƒç”¨**: Draw Callæ•°é‡å’Œç»Ÿè®¡
- **ç€è‰²å™¨æ€§èƒ½**: ç€è‰²å™¨ç¼–è¯‘å’Œæ‰§è¡Œæ—¶é—´
- **åƒç´ å¡«å……ç‡**: åƒç´ å¤„ç†æ€§èƒ½æŒ‡æ ‡
- **GPUç“¶é¢ˆ**: GPU vs CPUç“¶é¢ˆåˆ†æ

```cpp
// GPUåˆ†æç¤ºä¾‹
GPU_Metrics:
  gpu_usage: 92.3%
  vram_usage: 3.2GB / 8GB
  draw_calls: 15,234
  shader_compilation: 23ms
  pixel_fill_rate: 85.2M pixels/s
  bottlenecks: ["vertex_processing", "memory_bandwidth"]
```

## 4. å¿«é€Ÿå¼€å§‹

### ğŸš€ åŸºç¡€é›†æˆ

#### 1. ä¸‹è½½Tracy
```bash
# å…‹éš†ä»“åº“
git clone https://github.com/wolfpld/tracy.git
cd tracy

# æ„å»ºProfiler
cd profiler/build/unix
make -j$(nproc)
```

#### 2. é›†æˆåˆ°é¡¹ç›®
```cpp
// åœ¨ä½ çš„C++é¡¹ç›®ä¸­åŒ…å«Tracy
#include "tracy/Tracy.hpp"

// ä¸»å‡½æ•°ä¸­åˆå§‹åŒ–
int main() {
    // åˆå§‹åŒ–Tracyå®¢æˆ·ç«¯
    Tracy::SetupConfig();

    // ä½ çš„åº”ç”¨ä»£ç 
    run_application();

    return 0;
}
```

#### 3. æ·»åŠ æ€§èƒ½æ ‡è®°
```cpp
#include "tracy/Tracy.hpp"

void game_loop() {
    // å¸§çº§åˆ«æ ‡è®°
    ZoneScopedN("GameLoop");

    update_physics();
    render_frame();
    process_input();
}

void update_physics() {
    ZoneScopedN("PhysicsUpdate");

    // å…·ä½“æ“ä½œ
    for (auto& entity : entities) {
        entity.update();
    }
}
```

### ğŸ“Š å¯åŠ¨åˆ†æå™¨

```bash
# å¯åŠ¨Tracy Profiler GUI
./tracy-profiler

# æˆ–è€…ä½¿ç”¨captureæ¨¡å¼
./tracy-capture -o profile.tracy your_application
```

## 5. é›†æˆæŒ‡å—

### ğŸ”§ æ·±åº¦é›†æˆ

#### CMakeé›†æˆ
```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(MyApp)

# è®¾ç½®Tracyè·¯å¾„
set(TRACY_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/third_party/tracy")

# æ·»åŠ Tracyåº“
add_subdirectory(${TRACY_ROOT}/profiler/build/unix)

# é“¾æ¥åˆ°ä½ çš„ç›®æ ‡
target_link_libraries(MyApp PRIVATE tracy)
target_include_directories(MyApp PRIVATE ${TRACY_ROOT}/public)
```

#### ç¼–è¯‘é€‰é¡¹
```cmake
# Tracyç¼–è¯‘é…ç½®
target_compile_definitions(MyApp PRIVATE
    TRACY_ENABLE      # å¯ç”¨Tracy
    TRACY_ON_DEMAND   # æŒ‰éœ€æ¨¡å¼ï¼ˆæ¨èï¼‰
)

# è°ƒè¯•æ¨¡å¼
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_definitions(MyApp PRIVATE
        TRACY_CALLSTACK   # å¯ç”¨è°ƒç”¨æ ˆ
        TRACY_INVARIANT_CHECKS
    )
endif()

# å‘å¸ƒæ¨¡å¼
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    target_compile_definitions(MyApp PRIVATE
        TRACY_NO_CALLSTACK  # å‘å¸ƒæ¨¡å¼ç¦ç”¨è°ƒç”¨æ ˆ
    )
endif()
```

### ğŸ“± ä¸åŒå¹³å°æ”¯æŒ

#### Windows
```cpp
// Windowsç‰¹å®šé…ç½®
#ifdef _WIN32
    #define TRACY_DELAYED_INIT  // å»¶è¿Ÿåˆå§‹åŒ–
    #include <windows.h>
#endif
```

#### Linux/macOS
```cpp
// Unixç³»ç»Ÿé…ç½®
#ifdef __linux__
    #define TRACY_FIBERS  // ä½¿ç”¨Fibersè·å¾—æ›´å¥½çš„æ€§èƒ½
#endif

#ifdef __APPLE__
    #include <mach/mach_time.h>
#endif
```

#### ç§»åŠ¨å¹³å°
```cpp
// ç§»åŠ¨å¹³å°æ”¯æŒ
#ifdef ANDROID
    #include <android/log.h>
    #define TRACY_LOG_TO_LOGCAT
#endif

#ifdef IOS
    #define TRACY_ONLY_LOCALHOST
#endif
```

## 6. åˆ†æåŠŸèƒ½è¯¦è§£

### âš¡ å‡½æ•°æ€§èƒ½åˆ†æ

#### åŸºç¡€Zoneæ ‡è®°
```cpp
#include "tracy/Tracy.hpp"

void expensive_function() {
    ZoneScoped;  // è‡ªåŠ¨ä½¿ç”¨å‡½æ•°å

    // æˆ–ä½¿ç”¨è‡ªå®šä¹‰åç§°
    ZoneScopedN("CustomName");

    // å¸¦é¢œè‰²çš„Zone
    ZoneScopedC(0xFF0000);  // çº¢è‰²

    // å…·ä½“æ“ä½œ
    for (int i = 0; i < 1000; ++i) {
        // åµŒå¥—Zone
        ZoneScopedN("LoopIteration");
        process_item(i);
    }
}
```

#### æ¡ä»¶Zone
```cpp
void conditional_profiling(bool enable_profiling) {
    if (enable_profiling) {
        ZoneScopedN("ExpensiveOperation");
        perform_expensive_task();
    } else {
        perform_expensive_task();  // ä¸è®°å½•æ€§èƒ½
    }
}

// ä½¿ç”¨Tracyæ¡ä»¶ç¼–è¯‘
void smart_profiling() {
    ZoneScopedS(10);  // åªåœ¨10%çš„æƒ…å†µä¸‹è®°å½•
    occasional_expensive_task();
}
```

### ğŸ“Š ç»Ÿè®¡ä¿¡æ¯

#### ç»Ÿè®¡å˜é‡
```cpp
#include "tracy/Tracy.hpp"

// å®šä¹‰ç»Ÿè®¡å˜é‡
Tracy::PlotData<float, "fps">("Frames Per Second");
Tracy::PlotData<int64_t, "memory_usage">("Memory Usage");
Tracy::PlotData<float, "frame_time">("Frame Time");

void game_loop() {
    ZoneScopedN("GameLoop");

    // è®°å½•å¸§ç‡
    float fps = calculate_fps();
    fps.plot(fps);

    // è®°å½•å†…å­˜ä½¿ç”¨
    int64_t memory = get_memory_usage();
    memory_usage.plot(memory);

    // è®°å½•å¸§æ—¶é—´
    float frame_time = get_frame_time();
    frame_time.plot(frame_time);

    update_game();
    render_frame();
}
```

#### æ¶ˆæ¯è®°å½•
```cpp
#include "tracy/Tracy.hpp"

void log_performance_info() {
    // è®°å½•æ¶ˆæ¯
    TracyMessage("Performance data collected");
    TracyMessageL("Logging completed");

    // è®°å½•å¸¦é¢œè‰²çš„æ¶ˆæ¯
    TracyMessageC(0x00FF00, "Success: All systems operational");
    TracyMessageC(0xFF0000, "Warning: High memory usage detected");

    // åº”ç”¨ç¨‹åºæ¶ˆæ¯
    TracyAppInfo("Game Engine v1.0.0");
    TracyAppInfo("Build: Debug");
    TracyAppInfo("Platform: Windows 10");
}
```

### ğŸ¯ å†…å­˜åˆ†æ

#### å†…å­˜è¿½è¸ª
```cpp
#include "tracy/Tracy.hpp"

void memory_intensive_operation() {
    ZoneScopedN("MemoryOperation");

    // Tracyä¼šè‡ªåŠ¨è¿½è¸ªä»¥ä¸‹åˆ†é…
    char* buffer = new char[1024 * 1024];  // 1MB
    std::vector<int> large_vector(100000);

    // æ‰‹åŠ¨æ ‡è®°å†…å­˜åŒºåŸŸ
    void* custom_memory = malloc(1024);
    TracyAlloc(custom_memory, 1024);

    // ä½¿ç”¨å†…å­˜
    process_data(buffer, 1024 * 1024);

    // é‡Šæ”¾å†…å­˜
    delete[] buffer;
    large_vector.clear();

    free(custom_memory);
    TracyFree(custom_memory);
}
```

#### å†…å­˜æ± åˆ†æ
```cpp
class MemoryPool {
private:
    std::vector<void*> allocated_blocks;

public:
    void* allocate(size_t size) {
        ZoneScopedN("MemoryPoolAllocate");

        void* ptr = malloc(size);
        allocated_blocks.push_back(ptr);

        // è®°å½•åˆ†é…ä¿¡æ¯
        TracyAlloc(ptr, size);

        return ptr;
    }

    void deallocate(void* ptr) {
        ZoneScopedN("MemoryPoolDeallocate");

        auto it = std::find(allocated_blocks.begin(), allocated_blocks.end(), ptr);
        if (it != allocated_blocks.end()) {
            allocated_blocks.erase(it);
            TracyFree(ptr);
            free(ptr);
        }
    }

    void print_stats() {
        TracyMessage("Memory Pool Statistics:");
        TracyMessageL("Allocated blocks: " + std::to_string(allocated_blocks.size()));
    }
};
```

### ğŸ”’ é”åˆ†æ

#### äº’æ–¥é”åˆ†æ
```cpp
#include "tracy/Tracy.hpp"
#include <mutex>

std::mutex global_mutex;
std::shared_data shared_resource;

void thread_function(int thread_id) {
    ZoneScopedN("ThreadFunction");

    // Tracyä¼šè‡ªåŠ¨åˆ†æä»¥ä¸‹é”
    std::lock_guard<std::mutex> lock(global_mutex);
    ZoneScopedN("CriticalSection");

    // è®¿é—®å…±äº«èµ„æº
    shared_resource.process_data(thread_id);
}

// ä½¿ç”¨Tracyé”å°è£…
class TracyMutex {
private:
    std::mutex mutex;
    TracyLockableCtx lock_ctx;

public:
    void lock() {
        TracyLockable(mutex, lock_ctx);
    }

    void unlock() {
        TracyUnlockable(mutex);
    }
};
```

#### è¯»å†™é”åˆ†æ
```cpp
#include <shared_mutex>
#include "tracy/Tracy.hpp"

std::shared_mutex rw_mutex;
std::vector<int> shared_data;

void reader_thread() {
    ZoneScopedN("ReaderThread");

    // è¯»é”
    std::shared_lock<std::shared_mutex> lock(rw_mutex);
    ZoneScopedN("ReadOperation");

    // è¯»å–æ•°æ®
    int sum = 0;
    for (int value : shared_data) {
        sum += value;
    }
}

void writer_thread() {
    ZoneScopedN("WriterThread");

    // å†™é”
    std::unique_lock<std::shared_mutex> lock(rw_mutex);
    ZoneScopedN("WriteOperation");

    // ä¿®æ”¹æ•°æ®
    for (int& value : shared_data) {
        value *= 2;
    }
}
```

### ğŸ® æ¸¸æˆç‰¹å®šåˆ†æ

#### å¸§æ—¶é—´åˆ†æ
```cpp
#include "tracy/Tracy.hpp"
#include <chrono>

class GameEngine {
private:
    std::chrono::high_resolution_clock::time_point frame_start;
    float target_frame_time = 16.67f; // 60 FPS

public:
    void game_loop() {
        ZoneScopedN("GameLoop");

        while (is_running) {
            frame_start = std::chrono::high_resolution_clock::now();

            update_frame();
            render_frame();

            // åˆ†æå¸§æ—¶é—´
            auto frame_end = std::chrono::high_resolution_clock::now();
            float frame_time = std::chrono::duration<float, std::milli>(frame_end - frame_start).count();

            // è®°å½•å¸§ç‡
            float fps = 1000.0f / frame_time;
            TracyPlot("FPS", fps);

            // å¸§æ—¶é—´è­¦å‘Š
            if (frame_time > target_frame_time * 1.2f) {
                TracyMessageC(0xFF0000, "Frame time exceeded target!");
            }
        }
    }

    void update_frame() {
        ZoneScopedN("UpdateFrame");

        update_physics();
        process_input();
        update_ai();
    }

    void render_frame() {
        ZoneScopedN("RenderFrame");

        begin_render_pass();
        render_geometry();
        post_process();
        present();
    }
};
```

## 7. é«˜çº§é…ç½®

### âš™ï¸ é…ç½®é€‰é¡¹

#### æ€§èƒ½é…ç½®
```cpp
// Tracyæ€§èƒ½é…ç½®
struct TracyConfig {
    bool enable_callstack = true;           // å¯ç”¨è°ƒç”¨æ ˆ
    bool enable_sampling = false;          // å¯ç”¨é‡‡æ ·
    bool enable_memory_tracking = true;     // å¯ç”¨å†…å­˜è¿½è¸ª
    bool enable_frame_marking = true;      // å¯ç”¨å¸§æ ‡è®°

    // é‡‡æ ·é…ç½®
    uint32_t sampling_frequency = 1000;     // é‡‡æ ·é¢‘ç‡ (Hz)
    uint32_t max_callstack_depth = 64;      // æœ€å¤§è°ƒç”¨æ ˆæ·±åº¦

    // å†…å­˜é…ç½®
    size_t max_memory_usage = 1024 * 1024 * 1024; // 1GB

    // ç½‘ç»œé…ç½®
    bool enable_network = true;
    uint16_t port = 8086;

    // è¿‡æ»¤é…ç½®
    std::vector<std::string> include_zones;
    std::vector<std::string> exclude_zones;
};
```

#### è¿‡æ»¤è®¾ç½®
```cpp
// Zoneè¿‡æ»¤é…ç½®
void configure_filters() {
    Tracy::Config().SetZoneFilter([](const char* name) -> bool {
        // åŒ…å«çš„Zone
        if (strstr(name, "Render") || strstr(name, "Physics")) {
            return true;
        }

        // æ’é™¤çš„Zone
        if (strstr(name, "Debug") || strstr(name, "Log")) {
            return false;
        }

        return true; // é»˜è®¤åŒ…å«
    });
}
```

#### ç½‘ç»œé…ç½®
```cpp
// ç½‘ç»œåˆ†æé…ç½®
void setup_network_profiling() {
    // å¯ç”¨ç½‘ç»œåˆ†æ
    Tracy::SetNetworkMode(true);

    // é…ç½®ç½‘ç»œè¿‡æ»¤å™¨
    Tracy::SetNetworkFilter([](const char* address, uint16_t port) -> bool {
        // åªåˆ†æç‰¹å®šç«¯å£
        if (port == 80 || port == 443 || port == 8080) {
            return true;
        }
        return false;
    });
}
```

### ğŸ”Œ æ’ä»¶æ‰©å±•

#### è‡ªå®šä¹‰æ•°æ®æº
```cpp
// è‡ªå®šä¹‰æ•°æ®æºæ’ä»¶
class CustomDataSource {
private:
    Tracy::Connection* connection;

public:
    void register_data() {
        connection = &Tracy::GetConnection();

        // æ³¨å†Œè‡ªå®šä¹‰æ•°æ®ç±»å‹
        connection->RegisterSource("custom_data");
    }

    void send_custom_data(const std::string& data) {
        if (connection && connection->IsConnected()) {
            Tracy::MessagePack msgpack;
            msgpack.SetString("data", data.c_str());
            msgpack.SetInt64("timestamp", get_current_time());

            connection->SendNetMessage("custom_data", msgpack);
        }
    }
};
```

#### è‡ªå®šä¹‰åˆ†æå™¨
```cpp
// è‡ªå®šä¹‰æ€§èƒ½åˆ†æå™¨
class CustomAnalyzer {
public:
    void analyze_gpu_performance() {
        ZoneScopedN("GPUAnalysis");

        // è·å–GPUä¿¡æ¯
        GPU_Info gpu_info = get_gpu_info();

        // å‘é€GPUæ€§èƒ½æ•°æ®
        Tracy::MessagePack msgpack;
        msgpack.SetFloat("gpu_utilization", gpu_info.utilization);
        msgpack.SetFloat("memory_usage", gpu_info.memory_usage);
        msgpack.SetInt64("draw_calls", gpu_info.draw_calls);

        Tracy::GetConnection().SendNetMessage("gpu_info", msgpack);
    }

    void analyze_memory_allocation() {
        ZoneScopedN("MemoryAnalysis");

        MemoryStats stats = get_memory_stats();

        Tracy::MessagePack msgpack;
        msgpack.SetInt64("total_allocated", stats.total_allocated);
        msgpack.SetInt64("total_freed", stats.total_freed);
        msgpack.SetInt64("active_allocations", stats.active_count);

        Tracy::GetConnection().SendNetMessage("memory_stats", msgpack);
    }
};
```

## 8. æœ€ä½³å®è·µ

### ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–å»ºè®®

#### Zoneä½¿ç”¨æœ€ä½³å®è·µ
```cpp
// âœ… å¥½çš„Zoneä½¿ç”¨
void optimized_function() {
    ZoneScopedN("OptimizedFunction");

    // åœ¨å‡½æ•°å¼€å§‹æ—¶ç«‹å³æ ‡è®°
    auto start_time = std::chrono::high_resolution_clock::now();

    // ä¸»è¦å·¥ä½œ
    perform_heavy_computation();

    // è®°å½•é¢å¤–ä¿¡æ¯
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count();

    TracyMessageL("Computation time: " + std::to_string(duration) + " Î¼s");
}

// âŒ é¿å…çš„Zoneä½¿ç”¨
void bad_function() {
    // ä¸è¦åœ¨å¾ªç¯ä¸­åˆ›å»ºå¤ªå¤šZone
    for (int i = 0; i < 100000; ++i) {
        ZoneScopedN("LoopIteration");  // å¤ªå¤šZoneä¼šå½±å“æ€§èƒ½
        process_item(i);
    }
}

// âœ… å¾ªç¯ä¸­Zoneçš„æ›´å¥½åšæ³•
void good_function() {
    ZoneScopedN("ProcessingLoop");

    for (int i = 0; i < 100000; ++i) {
        process_item(i);

        // åªåœ¨ç‰¹å®šæ¡ä»¶ä¸‹è®°å½•
        if (i % 10000 == 0) {
            ZoneScopedS(1);  // 1%é‡‡æ ·ç‡
            TracyMessageL("Processed " + std::to_string(i) + " items");
        }
    }
}
```

#### å†…å­˜è¿½è¸ªæœ€ä½³å®è·µ
```cpp
class MemoryManager {
private:
    std::unordered_map<void*, size_t> allocations;
    TracyLockable(std::mutex, alloc_mutex);

public:
    void* allocate(size_t size) {
        void* ptr = malloc(size);

        // çº¿ç¨‹å®‰å…¨åœ°è®°å½•åˆ†é…
        {
            TracyLockZone(alloc_mutex);
            allocations[ptr] = size;
        }

        TracyAlloc(ptr, size);
        return ptr;
    }

    void deallocate(void* ptr) {
        if (!ptr) return;

        // çº¿ç¨‹å®‰å…¨åœ°ç§»é™¤è®°å½•
        size_t size = 0;
        {
            TracyLockZone(alloc_mutex);
            auto it = allocations.find(ptr);
            if (it != allocations.end()) {
                size = it->second;
                allocations.erase(it);
            }
        }

        TracyFree(ptr, size);
        free(ptr);
    }
};
```

#### çº¿ç¨‹åˆ†ææœ€ä½³å®è·µ
```cpp
// çº¿ç¨‹å‘½åå’Œæ ‡è®°
void worker_thread(int thread_id) {
    // ä¸ºçº¿ç¨‹è®¾ç½®æè¿°æ€§åç§°
    tracy::SetThreadName("Worker" + std::to_string(thread_id));

    ZoneScopedN("WorkerThread");

    while (running) {
        {
            ZoneScopedN("WaitForWork");
            wait_for_work();
        }

        {
            ZoneScopedN("ProcessWork");
            process_work_item();
        }
    }
}

// çº¿ç¨‹æ± ç®¡ç†
class ThreadPool {
private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;

public:
    void start(int num_threads) {
        for (int i = 0; i < num_threads; ++i) {
            workers.emplace_back([this, i] {
                tracy::SetThreadName("ThreadPool-" + std::to_string(i));

                ZoneScopedN("ThreadPoolWorker");

                while (true) {
                    std::function<void()> task;
                    {
                        ZoneScopedN("WaitForTask");
                        std::unique_lock<std::mutex> lock(queue_mutex);
                        condition.wait(lock, [this] { return !tasks.empty() || should_stop; });

                        if (should_stop) break;

                        task = std::move(tasks.front());
                        tasks.pop();
                    }

                    ZoneScopedN("ExecuteTask");
                    task();
                }
            });
        }
    }
};
```

## 9. æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

### ğŸ® æ¸¸æˆæ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

#### æ¡ˆä¾‹1ï¼šæ¸²æŸ“ä¼˜åŒ–
```cpp
// ä¼˜åŒ–å‰ï¼šè¿‡å¤šçš„Zoneæ ‡è®°
void render_scene() {
    ZoneScopedN("RenderScene");

    for (auto& object : scene_objects) {
        ZoneScopedN("RenderObject");  // å¤ªå¤šZone
        render_object(object);
    }
}

// ä¼˜åŒ–åï¼šåˆå¹¶Zone
void render_scene_optimized() {
    ZoneScopedN("RenderScene");

    // æŒ‰ç±»å‹åˆ†ç»„æ¸²æŸ“
    render_static_objects();
    render_dynamic_objects();
    render_transparent_objects();
}

void render_static_objects() {
    ZoneScopedN("RenderStaticObjects");

    int object_count = 0;
    for (auto& object : static_objects) {
        render_object(object);
        object_count++;
    }

    TracyMessageL("Rendered " + std::to_string(object_count) + " static objects");
}
```

#### æ¡ˆä¾‹2ï¼šå†…å­˜ä¼˜åŒ–
```cpp
// ä¼˜åŒ–å‰ï¼šé¢‘ç¹çš„å°å†…å­˜åˆ†é…
void process_particles() {
    ZoneScopedN("ProcessParticles");

    for (auto& particle : particles) {
        ParticleData* data = new ParticleData();  // é¢‘ç¹åˆ†é…
        particle.update(data);
        particle.render(data);
        delete data;  // é¢‘ç¹é‡Šæ”¾
    }
}

// ä¼˜åŒ–åï¼šå†…å­˜æ± 
class ParticleDataPool {
private:
    std::vector<ParticleData*> pool;
    std::queue<ParticleData*> available;

public:
    ParticleDataPool(size_t size) {
        pool.reserve(size);
        for (size_t i = 0; i < size; ++i) {
            ParticleData* data = new ParticleData();
            pool.push_back(data);
            available.push(data);
        }
        TracyAlloc(pool.data() * sizeof(ParticleData), size * sizeof(ParticleData));
    }

    ParticleData* acquire() {
        ZoneScopedN("AcquireParticleData");

        if (available.empty()) {
            TracyMessageC(0xFF0000, "ParticleDataPool exhausted!");
            return new ParticleData();  // Fallback
        }

        ParticleData* data = available.front();
        available.pop();
        return data;
    }

    void release(ParticleData* data) {
        ZoneScopedN("ReleaseParticleData");
        available.push(data);
    }
};

void process_particles_optimized() {
    ZoneScopedN("ProcessParticles");

    static ParticleDataPool pool(particles.size() * 2);

    for (auto& particle : particles) {
        ParticleData* data = pool.acquire();
        particle.update(data);
        particle.render(data);
        pool.release(data);
    }
}
```

#### æ¡ˆä¾‹3ï¼šå¤šçº¿ç¨‹ä¼˜åŒ–
```cpp
// ä¼˜åŒ–å‰ï¼šä¸»çº¿ç¨‹é˜»å¡
void load_assets() {
    ZoneScopedN("LoadAssets");

    load_textures();
    load_models();
    load_sounds();
    load_shaders();
}

// ä¼˜åŒ–åï¼šå¹¶è¡ŒåŠ è½½
void load_assets_optimized() {
    ZoneScopedN("LoadAssets");

    std::vector<std::future<void>> futures;

    // å¹¶è¡ŒåŠ è½½èµ„æº
    futures.push_back(std::async(std::launch::async, []() {
        ZoneScopedN("LoadTextures");
        load_textures();
    }));

    futures.push_back(std::async(std::launch::async, []() {
        ZoneScopedN("LoadModels");
        load_models();
    }));

    futures.push_back(std::async(std::launch::async, []() {
        ZoneScopedN("LoadSounds");
        load_sounds();
    }));

    // ä¸»çº¿ç¨‹åŠ è½½ç€è‰²å™¨ï¼ˆé€šå¸¸å¾ˆå¿«ï¼‰
    {
        ZoneScopedN("LoadShaders");
        load_shaders();
    }

    // ç­‰å¾…æ‰€æœ‰åŠ è½½å®Œæˆ
    for (auto& future : futures) {
        future.wait();
    }
}
```

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

### ä¼˜åŒ–å‰åå¯¹æ¯”

#### åº”ç”¨ç¨‹åºæ€§èƒ½
| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡ |
|------|--------|--------|------|
| **å¸§ç‡** | 45 FPS | 60 FPS | +33% |
| **å¸§æ—¶é—´** | 22ms | 16.7ms | -24% |
| **CPUä½¿ç”¨ç‡** | 85% | 70% | -18% |
| **å†…å­˜ä½¿ç”¨** | 512MB | 384MB | -25% |
| **åŠ è½½æ—¶é—´** | 15.2s | 8.7s | -43% |

#### Tracyåˆ†ææ•ˆæœ
| åŠŸèƒ½ | å¼€é”€ | å‡†ç¡®æ€§ | å®ç”¨æ€§ |
|------|------|--------|--------|
| **Zoneæ ‡è®°** | <1% | çº³ç§’çº§ | â­â­â­â­â­ |
| **å†…å­˜è¿½è¸ª** | <2% | å­—èŠ‚çº§ | â­â­â­â­â­ |
| **é”åˆ†æ** | <1.5% | å¾®ç§’çº§ | â­â­â­â­ |
| **GPUåˆ†æ** | <2% | æ¯«ç§’çº§ | â­â­â­â­ |

## ğŸ”— ç›¸å…³é“¾æ¥

### é¡¹ç›®èµ„æº
- ğŸ“¦ [GitHub ä»“åº“](https://github.com/wolfpld/tracy)
- ğŸ“– [å®˜æ–¹æ–‡æ¡£](https://github.com/wolfpld/tracy/wiki)
- ğŸ¥ [è§†é¢‘æ•™ç¨‹](https://www.youtube.com/@tracyprofiler)
- ğŸ’¬ [ç¤¾åŒºè®¨è®º](https://github.com/wolfpld/tracy/discussions)

### æŠ€æœ¯æ”¯æŒ
- ğŸ› [é—®é¢˜åé¦ˆ](https://github.com/wolfpld/tracy/issues)
- ğŸ“§ [é‚®ä»¶è”ç³»](mailto:wolf@tracy.guru)
- ğŸ”„ [æ›´æ–°æ—¥å¿—](https://github.com/wolfpld/tracy/releases)
- ğŸ’¡ [ä½¿ç”¨æŠ€å·§](https://github.com/wolfpld/tracy/wiki/Tips)

### ç›¸å…³å·¥å…·
- ğŸ”Œ [Tracyæ’ä»¶](https://github.com/wolfpld/tracy/wiki/Plugins)
- ğŸ“Š [ç¬¬ä¸‰æ–¹å·¥å…·](https://github.com/wolfpld/tracy/wiki/Third-party-tools)
- ğŸ® [æ¸¸æˆå¼•æ“é›†æˆ](https://github.com/wolfpld/tracy/wiki/Engine-integrations)

## æ€»ç»“

Tracy Profiler ä½œä¸ºæ–°ä¸€ä»£C++æ€§èƒ½åˆ†æå·¥å…·ï¼Œä¸ºå¼€å‘è€…æä¾›äº†ï¼š

- **âš¡ æè‡´æ€§èƒ½** - çº³ç§’çº§ç²¾åº¦ï¼Œæœ€å°æ€§èƒ½å¼€é”€
- **ğŸ“Š å…¨é¢åˆ†æ** - CPUã€GPUã€å†…å­˜ã€é”ç­‰å¤šç»´åº¦åˆ†æ
- **ğŸ® æ¸¸æˆä¼˜åŒ–** - ä¸“ä¸ºæ¸¸æˆå¼€å‘ä¼˜åŒ–çš„åˆ†æåŠŸèƒ½
- **ğŸ”§ æ˜“äºé›†æˆ** - ç®€å•APIï¼Œé›¶é…ç½®å³å¯ä½¿ç”¨
- **ğŸ“ˆ å®æ—¶åé¦ˆ** - åº”ç”¨è¿è¡Œæ—¶å³å¯æŸ¥çœ‹æ€§èƒ½æ•°æ®

æ— è®ºæ˜¯æ¸¸æˆå¼€å‘ã€é«˜æ€§èƒ½è®¡ç®—ï¼Œè¿˜æ˜¯æ¡Œé¢åº”ç”¨å¼€å‘ï¼ŒTracyéƒ½èƒ½å¸®åŠ©å¼€å‘è€…å¿«é€Ÿå®šä½æ€§èƒ½ç“¶é¢ˆï¼Œä¼˜åŒ–åº”ç”¨ç¨‹åºæ€§èƒ½ï¼Œåœ¨ç«äº‰æ¿€çƒˆçš„å¸‚åœºä¸­è·å¾—æ›´å¥½çš„ç”¨æˆ·ä½“éªŒã€‚